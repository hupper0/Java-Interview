### 分布式系统的缓存
参考：https://blog.csdn.net/jake_li/article/details/50659868
#### 1、缓存概述
* 概念：存储数据的硬件和软件的租车部分，数据副本
* 作用：解决高并发、大数据场景下、热点数据下访问性能
* 原理：将数据提前写入读取更快的介质、将数据写到距离访问端更近的位置、将数据写到距离应用更近的位置

#### 2、分类 
cdn缓存、反向代理缓存、本地缓存、分布式缓存
##### 2.1 CDN缓存
* 基本介绍：CDN(Content Delivery Network 内容分发网络)的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。
* 应用场景：主要缓存静态资源，例如图片，视频
* 优点：
	* 镜像服务：消除了不同运营商之间互联瓶颈造成的影响，实现了跨境运营商网络加速
	* 远程加速：
	* 带宽加速：
	* 集群抗攻击
		
##### 2.2 反向代理缓存
* 基本概述：反向代理位于应用服务器机房，处理所有对WEB服务器的请求。
如果用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发送给用户。通过降低向WEB服务器的请求数，从而降低了WEB服务器的负载。
* 应用场景： 缓存体积较小静态文件资源，如css、js、图片
* 开源实现： nginx、varnish、squid

##### 2.3 本地应用缓存
* 基本概念：指的是在应用中的缓存组件，其最大的优点是应用和cache是在同一个进程内部，请求缓存非常快速，没有过多的网络开销等，在单应用不需要集群支持或者集群情况下各节点无需互相通知的场景下使用本地缓存较合适；同时，它的缺点也是应为缓存跟应用程序耦合，多个应用程序无法直接的共享缓存，各应用或集群的各节点都需要维护自己的单独缓存，对内存是一种浪费。
* 缓存介质：
	* 硬盘缓存：减少了网络开销，对速度要求不高
	* 内存缓存：数据缓存到本机内存、应用程序直接缓存 
* ehcache:
	* 基本介绍：Ehcache是一种基于标准的开源缓存，可提高性能，卸载数据库并简化可伸缩性。 它是使用最广泛的基于Java的缓存，因为它功能强大，经过验证，功能齐全，并与其他流行的库和框架集成。Ehcache可以从进程内缓存扩展到使用TB级缓存的混合进程内/进程外部署 
	* 特点：
		* 快速
		* 简单，依赖包小，配置简单
		* 支持多种缓存策略，灵活
		* 缓存策略内存和硬盘
		* 支持多缓存管理器实例、以及一个实例多个缓存区域 
	* 缓存过期策略：
		* FIFO
		* LFU
		* LRU 
* guva cache:
	* 特点&功能：
		* 自动将entry节点加载缓存结构中
		* 数据超过设置的最大值时，使用lru算法移除
		* 缓存的key被封装在weakreference引用内
		* 缓存的value被封装在weakreference或者softreference引用内
		* 统计缓存使用过程中命中率、异常率、未命中率等统计数据
	* 数据结构：继承了concurrenthashmap思路,使用多个segment细粒度锁，保证线程安全的同时，支持高并发锁
	* 与map类似，他是存储键值对的集合，不同的是他需要处理evict、expire、dynamic load等算法逻辑
	* 缓存更新策略：初始化加载、基于回调函数加载
	* 回收策略：基于容量、定时回收、基于引用回收、显示清除
 
#####2.4 分布式缓存
* 基本概念：指的是与应用分离的缓存组件或服务，其最大的优点是自身就是一个独立的应用，与本地应用隔离，多个应用可直接的共享缓存
* memcached
	* memcached是一个高性能，分布式内存对象缓存系统，通过在内存里维护一个统一的巨大的hash表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。
	* 特点：
		* 使用物理内存作为缓存，可独立部署在服务器上，每个进程最大2G.
		* 使用key-value方式存储数据，
		* 协议简单：基于文本行的协议
		* 基于libevent高性能通信， libevent是利用了c开发的程序库，将bsd系统kqueue，linux系统epoll等事件处理功能封装一个接口，比传统的select模型性能优秀
* Redis：
	* 基本介绍：Redis是一个远程内存数据库（非关系型数据库），性能强劲，具有复制特性以及解决问题而生的独一无二的数据模型。它可以存储键值对与5种不同类型的值之间的映射，可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能，
Redis还可以使用客户端分片来扩展写性能。内置了 复制（replication），LUA脚本（Lua scripting），LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）
	* 淘汰策略：
		* volatile-lru:
		* volatile-ttl
		* volatile-random
		* allkeys-lru
		* allkeys-random
		* no-enviction
	* 持久化方式：
		* rdb:redis database,默认支持方式，数据库快照snapshot以二进制方式定时保存到磁盘
		* aof:append only file 以协议文本的方式，将所有对数据库进行写的命令记录到aof文件，以此达到数据库状态的目的
	* 缓存设计原则：
		* 将热点数据放到缓存里
		* 缓存过期时间应该分散到
		* key 压缩，分散，区分不同业务
		* 避免使用 keys* 
		* 缓存预热
		* 读的顺序:先缓存后数据库，写的顺序 先数据库后缓存

		| 对比   |      Redis      |  Memcached |
		|----------|:-------------:|------:|
		| 数据结构 |  哈希、列表、集合、有序集合 | 纯kev-value|
		| 持久化支持 |    有   |   无 |
		| 高可用支持 | redis天然支持集群功能，可以实现主动复制，读写分离。官方也提供了sentinel集群管理工具，能够实现主从服务监控，故障自动转移，这一切，对于客户端都是透明的，无需程序改动，也无需人工介入 |    需要二次开发|
		| 存储value容量 |    最大512M   |   最大1M |
		| 虚拟内存使用 |    有自己的VM机制，理论上能够存储比物理内存更多的数据，当数据超量时，会引发swap，把冷数据刷到磁盘上|   所有的数据存储在物理内存里 |
		| 网络模型 |    非阻塞IO复用模型,提供一些非KV存储之外的排序，聚合功能，在执行这些功能时，复杂的CPU计算，会阻塞整个IO调度 |   非阻塞IO复用模型 |
		| 多线程	 |    Redis支持单线程	   |   Memcached支持多线程,CPU利用方面Memcache优于Redis |
		| 单机QPS	 |   约10W   |   约60W |
	

#### 缓存带来的复杂度问题
* 1、数据一致性
* 2、缓存穿透
	* 概述：缓存一般是Key，value方式存在，当某一个Key不存在时会查询数据库，假如这个Key，一直不存在，则会频繁的请求数据库，对数据库造成访问压力。
	* 解决办法：1、对结果为空的数据也进行缓存，当此key有数据后，清理缓存 2、一定不存在的key，采用布隆过滤器，建立一个大的Bitmap中，查询时通过该bitmap过滤
* 3、缓存雪崩
	* 概述：缓存失效后，导致的系统性能极具下降，高并发情况下 缓存集体失效
	* 解决办法：1、更新锁机制：缓存更新操作进行加锁保护，保证只有一个线程更新缓存 2、后台更新机制：后台线程更新缓存，  
* 4、缓存高可用
* 5、缓存热点
	* 概述：一些特别热点的数据，高并发访问同一份缓存数据，导致缓存服务器压力过大。
	* 解决：复制多份缓存副本，把请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力
 

* 6、缓存使用小技巧：
	* 服务与服务之间不要通过缓存传递数据
	* 如果缓存挂掉，可能导致雪崩，此时要做高可用缓存，或者水平切分
	* 调用方不宜再单独使用缓存存储服务底层的数据，容易出现数据不一致，以及反向依赖
	* 不同服务，缓存实例要做垂直拆分













